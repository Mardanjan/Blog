1. ### DOCTYPE有什么用？标准模式与混杂模式如何区分？它们有何意义
doctype告诉浏览器使用哪个版本的html规范来渲染文档，doctype不保存在或形式不正确会导致html文档义混杂模式呈现  
标准模式以浏览器    支持的最高标准运行，混杂模式中页面是一种比较宽松的向后兼容的方式显示  


2. ### 对浏览器内核的理解
内核主要分成两个部分，渲染引擎和js引擎  
js引擎：解析和执行JavaScript来实现网页的动态效果  
渲染引擎：负责取得网页的内容（HTML，XML，图像等），整理信息（例如加入css等），以及计算网页的显示方式，然后会输出到显示设备  
浏览器的内核不同，对网页的语法的解释会不同，所以渲染的效果也不同  


3. ### HTML5 webworker
webworke是html5的新特性之一，是一个JavaScript多线程解决方案，我们可以将一些计算量大的任务代码交给webworker来运行，而不用冻结用户界面

4. ### 元素属性src和href的区别
功能不同，href能建立一条通道，将当前文档和定义的资源连接起来  
src（source）将定义的资源嵌入到当前文档中

5. ### 以下代码运行后，p的颜色是
```
<meta http=equiv="default-Style" content="red"/>
<style title="red">
p{
    color:red;
}
</style>
<style title="blue">
p {
    color: blue;
}
</style>
```
为两段内嵌样式定义了title属性，（即为该样式表命名），可用于设置首选样式表，由于在meta元素中吧red的样式表设置为了首选样式表，因此p元素中的文本为红色显示

6. ### 外部样式可以用link元素引用，其结构为如下代码所示，其中rel属性的作用是什么
```
<link rel="stylesheet" type="text/css" href="css/style.css">
```
link元素除了拥有全局属性外，还包含5个特殊属性，type，media，title，href和ref，其中ref属性用于定义当前文档与目标资源的关系，用stylesheet表示文档的外部样式

7. ### 用meta的两种生命方式，把当前html文档中的内容用UTF-8进行编码
charset是html5新增的属性，可用来表示html文档中的内容所用的字符编码，定义的属性值不区分大小写
```
<meta charset="UTF-8" />
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

```

8. ### 视口
视口是指不包括浏览器外壳（标签页，书签栏，调试工具等）的窗口，也就是文档内容的可视区域  


9. ### meta元素的http-equiv属性所拥有的功能
1。 定义mime类型与字符编码  
2。 制定首选样式表  
3。 执行重载或重定向  
http-equip 提供了一些程序指令，用于模拟http首部，每个http-equiv属性值会对应特定的content值。在http-equiv中包含三个关键字，分别是content-type，default-style和refresh，分别对应上面的效果  
  

10. ### meta元素可以定于文档的那些元数据
1。 html文档所用的编码方式
2。 完善文档的描述信息，让搜索引擎更容易解析索引，提升seo
3。 适配移动设备，使页面在各种尺寸的屏幕中显示正确
4。 制定首选样式表，执行重载或重定向  

11. ### 超链接和图像之a标签
a标签可以用来导航到其它网页，打电话，发短信，发邮件，长见识了  

12. ### 什么是锚点
锚点（anchor）是一种特殊的链接，能定位到html文档中的某个特定位置，这个文件既可以在当前的域名下，也可以在其它域名下
```
<a href="#"> 返回顶部
<a href="#anchor"> 内部定位
<a href="http://baidu.com#anchor">外部定位
```
通过html元素的id或name属性来设置锚点，目前a元素可以用name属性来设置锚点，但html5将a元素的name属性抛弃了，所以推荐的用法是用id属性来设置锚点

13. ### a标签的tatger属性
有四个关键字可以选，self，blank，parent，top  
parent表示父窗口，如果没有父窗口则与self一样  
top表示顶层窗口，如果没有顶层，则与self一样

14. ### 分区响应图
让图像上的部分位置有超链接，当超链接按钮是图像的时候，将图片进行划分，使得点击图片不同的区域时，会有不同的返回


## canvas
+ 通过JavaScript来绘制2D图形
+ 是逐像素进行渲染的
+ 其位置发生改变，会重新进行绘制

## SVG
+ 一个使用XML描述的2D图形的语言
+ SVG基于XML意味着，SVG DOM 中的每一个元素都是可用的，可以为某个元素附加JavaScript事件处理器
+ 在SVG中，每个被绘制的图像均被视为对象。如果SVG对象的属性发生变化，那么浏览器能够自动重现图形

## 比较
+ canvas
- 依赖分辨率
- 不支持事件处理
- 弱的文本渲染能力
- 能够以.png或.jpg格式保存结果图像
- 最适合图像密集型的游戏，其中的许多对象会被 频繁重绘
+ svg
- 不依赖分辨率
- 支持事件处理
- 最适合带有大型渲染区域的应用程序（比如谷歌地图）
- 复杂度高会减慢渲染速度（任何过度使用dom的应用都不快）
- 不适合游戏应用


## 箭头函数
+ 箭头函数不能作为构造函数，因为没有this
+ 箭头函数没有prototype属性
+ 箭头函数不绑定Argements对象

## arguments对象
+ 函数调用的时候浏览器会给函数传进两个隐式参数
- this 上下文环境
- arguments封装实参的对象
+ JavaScript的参数是形参，可以传也可以不传，声明函数的时候可以声明形参也可以不声明，最好声明，提升代码的阅读型
+ arguments对象有length属性，可以知道参数的数量，跟数组一样获取参数，但是它不是一个参数，他没有push等数组该有的方法 

## promise 的优缺点
+ 优点：让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一套接口可以实现许多很强大的功能，比如同时执行多个异步操作，等到他们的状态都改变以后再执行一个回调函数，再比如，为多个回调函数中抛出的错误统一制定处理方法

+ 有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态，这意味着无论何时为promise实例添加回调函数，该函数都能正确的执行

+ 缺点：编写的难度比传统方法高，而且阅读代码也不是一眼可以看懂的，你只会看到一堆then，必须自己在then的回调函数里理清逻辑

## async函数
+ 我敲喜欢用这个
+ 在普通函数前面加async，就意味着函数内包含了异步操作。
+ async告诉程序这是个异步操作，await是一个操作符，即await后面是一个表达式   
+ 当调用一个async函数时，会返回一个promise对象，根据mdn的解释**当这个async函数返回一个值时，Promise的resolve方法会负责传递这个值**  当async函数抛出异常时，promise的reject方法也会传递这个异常值async函数中可能会有await表达式，await表达式会使async函数暂停执行，直到表达式中的promise解析完成后继续执行，执行async中await后面的代码并返回解决结果
+ await关键字仅仅在async函数中有效
+ 既然返回的是Promise对象，所以在最外层不能用await获取其返回值的情况下，那么肯定可以用原来的方式：then（）链来处理这个Promise对象
+ 如果async函数没有返回值，又怎么样呢？很容易想到，它会返回Promise.resolve(undefined)
+ 联想一下Promise的优点无等待，所以在没有await的情况下执行async函数，它会立即执行，返回一个Promise对象，并且，绝不会阻塞后面的语句
+ await操作符：await表达式会暂停当前async function的执行，等待Promise处理完成。若Promise正常处理，其回调的resolve函数参数为awaiit表达式的值，否则async表达式会把Promise的异常原因抛出。另外，如果await操作符后面的表达式的值不是一个Promise，则返回该值本身
+ 通俗的说：async函数返回一个Promise对象，当函数执行的时候，一旦遇到await就先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句，不会阻塞主线程

## 回流和重绘
+ 回流和重绘我经常听到（刷面试题的时候就有），但是在我的脑海里对重绘有一丁点的印象，这也是自己根据重绘这个单词的理解来想出来的，现在花点时间理解一下这两个好东西

## 浏览器的渲染过程
+ 1. 解析html，生成dom树，解析css生成cssom树
+ 2. 将dom树和cssom树结合，生成渲染树
+ 3. layout（回流）：根据生成的渲染树，进行回流（Layout），得到节点的几何信息（位置，大小）
+ 4. Painting（重绘）：根据渲染树以及回流得到的几何信息，得到节点的绝对像素
+ 5. display：将像素发送给显卡，展示在页面上

## 生成渲染树
+ 从dom树的根节点开始遍历每一个可见节点
+ 对于每一个节点，找到css样式表中对应的规则，并应用它们
+ 根据每个可见节点以及其对应的样式，组合生成渲染树
### 不可见的节点：
- 一些不会渲染输出的节点，比如script，meta，link等
- 一些通过css进行隐藏的节点，比如display：none，visibility和opacity隐藏的节点还是会显示在渲染树上面的
+ **渲染树只包含可见的节点**

## 回流
+ 前面我们通过构造渲染树，我们将可见dom节点以及它对应的样式结合起来，可是我们还需要计算他们在设备视口内的确切的位置和大小，这个计算就是回流

## 重绘
+ 最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息（位置和大小），那么我们就可以将渲染树的每个节点转换为屏幕上的实际像素，这个阶段就叫做重绘节点。

## 何时会发生重绘
+ 回流这一阶段主要是计算节点的位置和几何信息，那么当前页面布局和几何信息发生变化的时候就需要回流，比如以下情况：
- 添加或删除可见的dom元素
- 元素的位置发生变化
- 元素的尺寸发生变化
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所代替
- 页面一开始渲染的时候
- 浏览器窗口尺寸变化，因为回流是根据视口的大小计算元素的位置和大小的
+ **回流一定会触发重绘，而重绘不一定触发回流**
+ 根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的回流，比如出现滚动条或者修改了根节点

## 浏览器的优化机制
+ 现代浏览器都是很聪明的，由于每次回流都会造成额外的计算消耗，因此大多数浏览器会通过队列化修改并批量执行来优化回流过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阀值，才会清空队列，但是，**当你获取布局信息的操作的时候，会强制队列刷新**，比如当你访问以下属性或者使用以下方法：
- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect
+ 以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列，如果要使用它们，最好将值缓存起来。

## 减少回流和重绘
### 最小化回流和重绘
+ 由于重绘和回流的代价比较昂贵，因此最好就是可以减少它们的发生次数。为了减少发生次数，我们可以合并多次对dom和样式的修改，然后一次处理掉

## 批量修改DOM
+ 使元素脱离文档流
+ 对其进行多次修改
+ 将元素带回文档中
- 第一步和第三步可能会引起回流，但是经过第一步之后，对dom的所有修改都不会引起回流，因为它已经不在渲染树上了
+ 有三种方法可以让dom脱离文档流：
- 隐藏元素，应用修改，重新显示
- 使用文档片段，在当前dom之外构建一个子树，再把它拷贝会文档
- 将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素
+ 隐藏元素----修改----显示

## 设计模式
+ 什么是设计模式？
设计模式是一套反复使用的并且经过分类编目的代码设计经验总结
+ 设计模式有哪些
创建型模式  
结构性模式  
行为性模式  
在前端开发中有些特定的模式不太适用。当然，有些适用于前端的模式并未包含在这里面，如委托模式，节流模式等  
## 工厂模式
它的优点是可以使用工厂方法而不是new关键字消除对象间的耦合。同时将所有实例化的代码封装在一起，实现代码重复。工厂模式解决了重复创建对象的问题  
```
  function factory (name) {
      var user = new Object()
      user.name = name
      return user
  }
  mardan = factory ('mardan')
```
## 工厂模式的概念是什么？
工厂模式需要三个基本步骤，原料投入（传参），加工（创建对象，把接受的参数赋值给对象），成品产出（返回对象）

## 工厂模式的缺陷是什么？
1. 没有使用new关键字，在创建对象的过程中，看不到构造函数实例化的过程  
2. 每个实例化的对象都可以创建相应的变量和函数，因此需要更多的空间进行属性和方法的存储，从而降低了性能，造成了资源浪费  

## 说说mvc架构和mvvm架构的理解
+ 在典型的mvc架构中，包含3部分，模型，视图，和控制器。控制器可以访问视图，让其更新，控制器可以访问模型，更新数据，视图可以访问模型，获取数据渲染页面  
+ 在mvvm架构中，包含3部分，即模型，视图和视图模型，视图模型负责视图与模型之间的信息转换，通过数据双向绑定试视图与模型之间的数据得以传递
mvvm前端框架有：Vue.js and Angular.js

## 什么是事件代理
事件代理又称为事件委托，是JavaScript中常见的事件的绑定方式，顾名思义‘事件代理’就是把原本需要绑定到子元素的事件委托给父元素，让父元素承担事件监听的工作，事件代理的原理是dom元素的事件冒泡，使用事件代理的好处很多，如减少事件数量，预测未来元素，避免内存外泄等，有利于提高性能

## 说说工厂模式的优缺点
+ 优点：
一个调用者想创建一个对象，只要知道它的名称即可  
扩展性高，如果想增加一个产品，只要扩展一个工厂类即可  
屏蔽产品的具体实现，调用者只需担心产品的接口  
+ 缺点：
每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数数倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖

## 使用工厂模式最主要的好处是什么？
把对象的创建几种在一个地方，在增加新的对象类型的时候，只需要改变工厂的方法，当不适用工厂模式的时候，改变创建方式则需要四处修改，增加维护成本


# 继承

+ 面向对象的编程很重要的一个方面，就是对象的继承，A对象通过继承B对象，就能直接拥有B对象的所有的方法和属性，这对于代码的复用性是非常有用的

+ 想c++ 和 java这种面向对象的语言是通过类的继承来实现继承的，但是JavaScript是通过原型对象prototype来实现的，以下是js中常见的继承方式

## 原型链继承


































