/**
 * DNA匹配（Web）
时间限制：C/C++语言 1000MS；其他语言 3000MS
内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述：
有一种特殊的DNA，仅仅由核酸A和T组成，长度为n，顺次连接

科学家有一种新的手段，可以改变这种DNA。每一次，科学家可以交换该DNA上两个核酸的位置，也可以将某个特定位置的核酸修改为另一种核酸。

现在有一个DNA，科学家希望将其改造成另一种DNA，希望你计算最少的操作次数。

输入
输入包含两行，第一行为初始的DNA，第二行为目标DNA，保证长度相同。

输出
输出最少的操作次数


样例输入
ATTTAA
TTAATT
样例输出
3
提示
对于100%的数据，DNA长度小于等于100000
样例解释：
1.首先修改第一个位置的核酸（从A修改为T）
2.交换3和5位置的核酸
3.交换4和6位置的核酸

我的理解是 交换3和5算一次操作，交换4和6也是，修改一个也算一次操作
所以先把能互相替换的都替换掉，这样就修复了 n*2
再把只能修改自己的修改一下，这样修改次数就等于最长的数组的长度了
 */


var str1 = 'ATTTAA'
var str2 = 'TTAATT'
var a1 = []
var a2 = []
for (let i = 0; i < str1.length; i++) {
  if (str1[i] !== str2[i]) {
    if (str1[i] === 'T') {
      a1.push(str1[i])
    } else {
      a2.push(str1[i])
    }
  }
}
// console.log(a1)
// console.log(a2)
var num = 0
num = a1.length > a2.length ? a1.length : a2.length

console.log(num)

/**
 * 时间限制：C/C++语言 1000MS；其他语言 3000MS
内存限制：C/C++语言 65536KB；其他语言 589824KB
题目描述：
A和B两个人在抽奖。现在有一个抽奖箱，里面有n张中奖票，m张不中奖票。A和B轮流从中抽一张奖票出来。如果有人抽到中奖票就结束，抽到中奖票的人胜利。抽过的奖票会被丢弃。

额外的，B每次抽后，会再次抽取一张票并丢弃掉（这张票中奖不算B胜利）。

现在，A先抽，请问A的胜率，保留4位小数后输出。

如果两人到最后也没有抽到中奖票算作B胜利。

输入
输入两个数字n,m，代表中奖票和不中奖票的数量 (0≤n,m≤1000)

输出
输出A的胜率，保留4位小数。


样例输入
2 3
样例输出
0.6000

提示
样例输入2
1 3
样例输出2
0.5000
样例二解释：
如果A第一轮抽到中奖票，A胜利，概率0.25。
如果A第二轮抽到中奖票，情况为A第一轮没有抽到中奖票，B也没有抽到中奖票，并且B丢弃掉的奖票也不是中奖票。概率为3/4 * 2/3 * 1/2=0.25
综上，中奖率为0.5。
 */